/* e8c1a6f7aa0a3ed7a40dd63f5d2d85d81cff49e4
 * This file is automatically generated by graphql-let. */

import * as Types from '../../../__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type QuestionPartsFragment = { __typename?: 'Question', id: string, question?: string | null, answer?: string | null, created_at?: any | null, positive_feedbacks_count?: number | null, negative_feedbacks_count?: number | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, my_feedback?: { __typename?: 'Feedback', id: string, positive?: boolean | null, negative?: boolean | null } | null };

export type ProductsQueryVariables = Types.Exact<{
  search?: Types.InputMaybe<Types.Scalars['String']['input']>;
  date_range?: Types.InputMaybe<Types.Scalars['String']['input']>;
  orderBy?: Types.InputMaybe<Types.Scalars['String']['input']>;
  sortedBy?: Types.InputMaybe<Types.Scalars['String']['input']>;
  language?: Types.InputMaybe<Types.Scalars['String']['input']>;
  searchJoin?: Types.InputMaybe<Types.Scalars['String']['input']>;
  first?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  page?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type ProductsQuery = { __typename?: 'Query', products: { __typename?: 'ProductPaginator', data: Array<{ __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, author?: { __typename?: 'Author', name: string, slug?: string | null, id: string } | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null }>, paginatorInfo: { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number } } };

export type ProductPartsFragment = { __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null };

export type PaginatorPartsFragment = { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number };

export type ProductQueryVariables = Types.Exact<{
  id?: Types.InputMaybe<Types.Scalars['ID']['input']>;
  slug?: Types.InputMaybe<Types.Scalars['String']['input']>;
  language?: Types.InputMaybe<Types.Scalars['String']['input']>;
}>;


export type ProductQuery = { __typename?: 'Query', product: { __typename?: 'Product', shop_id?: string | null, description?: string | null, id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, author?: { __typename?: 'Author', id: string, name: string, slug?: string | null, is_approved?: boolean | null, bio?: string | null, quote?: string | null, born?: string | null, death?: string | null, languages?: string | null, socials?: Array<{ __typename?: 'ShopSocials', url?: string | null, icon?: string | null }> | null, image?: { __typename?: 'Attachment', id?: string | null, original?: string | null, thumbnail?: string | null } | null, cover_image?: { __typename?: 'Attachment', id?: string | null, original?: string | null, thumbnail?: string | null } | null } | null, manufacturer?: { __typename?: 'Manufacturer', id: string, name: string, slug?: string | null } | null, shop?: { __typename?: 'Shop', id: string, name?: string | null, slug?: string | null } | null, categories?: Array<{ __typename?: 'Category', id: string, name: string, slug: string, children?: Array<{ __typename?: 'Category', id: string, name: string, slug: string } | null> | null }> | null, gallery?: Array<{ __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null }> | null, video?: Array<{ __typename?: 'Video', url: string }> | null, variations?: Array<{ __typename?: 'AttributeValue', id: string, value: string, meta?: string | null, attribute: { __typename?: 'Attribute', id: string, name: string, slug: string } }> | null, variation_options?: Array<{ __typename?: 'Variation', id: string, title: string, price: number, sale_price?: number | null, quantity: number, is_disable: boolean, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, options: Array<{ __typename?: 'VariationOption', name: string, value: string }> }> | null, related_products?: Array<{ __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null }> | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null } };

export type AuthorPartsFragment = { __typename?: 'Author', id: string, name: string, is_approved?: boolean | null, slug?: string | null, bio?: string | null, quote?: string | null, born?: string | null, death?: string | null, languages?: string | null, socials?: Array<{ __typename?: 'ShopSocials', url?: string | null, icon?: string | null }> | null, image?: { __typename?: 'Attachment', id?: string | null, original?: string | null, thumbnail?: string | null } | null, cover_image?: { __typename?: 'Attachment', id?: string | null, original?: string | null, thumbnail?: string | null } | null };

export type PopularProductsQueryVariables = Types.Exact<{
  limit?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  type_slug?: Types.InputMaybe<Types.Scalars['String']['input']>;
  range?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type PopularProductsQuery = { __typename?: 'Query', popularProducts: Array<{ __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, author?: { __typename?: 'Author', name: string, slug?: string | null, id: string } | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null }> };

export type BestSellingProductsQueryVariables = Types.Exact<{
  limit?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  type_slug?: Types.InputMaybe<Types.Scalars['String']['input']>;
  range?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type BestSellingProductsQuery = { __typename?: 'Query', bestSellingProducts: Array<{ __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, author?: { __typename?: 'Author', name: string, slug?: string | null, id: string } | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null }> };

export type DownloadableProductsQueryVariables = Types.Exact<{
  first?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  page?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type DownloadableProductsQuery = { __typename?: 'Query', downloads: { __typename?: 'OrderedFilePaginator', data: Array<{ __typename?: 'OrderFiles', id: string, purchase_key?: string | null, digital_file_id?: number | null, tracking_number?: string | null, created_at?: any | null, file?: { __typename?: 'DigitalFile', fileable?: { __typename: 'Product', name: string, slug: string, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, shop?: { __typename?: 'Shop', name?: string | null, slug?: string | null } | null } | { __typename: 'Variation', title: string, product?: { __typename?: 'Product', name: string, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null } | null } | null } | null, order?: { __typename?: 'Order', payment_status?: string | null, order_status?: string | null, payment_gateway: Types.PaymentGatewayType, payment_intent?: { __typename?: 'PaymentIntent', id: string, order_id: string, payment_gateway: string, tracking_number: string, payment_intent_info?: { __typename?: 'PaymentIntentInfo', client_secret?: string | null, is_redirect: boolean, payment_id: string, redirect_url?: string | null, amount: string, currency: string } | null } | null } | null }>, paginatorInfo: { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number } } };

export type PaymentIntentPartsFragment = { __typename?: 'PaymentIntent', id: string, order_id: string, payment_gateway: string, tracking_number: string, payment_intent_info?: { __typename?: 'PaymentIntentInfo', client_secret?: string | null, is_redirect: boolean, payment_id: string, redirect_url?: string | null, amount: string, currency: string } | null };

export type QuestionsQueryVariables = Types.Exact<{
  shop_id?: Types.InputMaybe<Types.Scalars['ID']['input']>;
  orderBy?: Types.InputMaybe<Array<Types.QueryQuestionsOrderByOrderByClause> | Types.QueryQuestionsOrderByOrderByClause>;
  first?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  page?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type QuestionsQuery = { __typename?: 'Query', questions: { __typename?: 'QuestionPaginator', data: Array<{ __typename?: 'Question', id: string, question?: string | null, answer?: string | null, created_at?: any | null, positive_feedbacks_count?: number | null, negative_feedbacks_count?: number | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, my_feedback?: { __typename?: 'Feedback', id: string, positive?: boolean | null, negative?: boolean | null } | null }>, paginatorInfo: { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number } } };

export type MyQuestionsQueryVariables = Types.Exact<{
  orderBy?: Types.InputMaybe<Array<Types.QueryMyQuestionsOrderByOrderByClause> | Types.QueryMyQuestionsOrderByOrderByClause>;
  first?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  page?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type MyQuestionsQuery = { __typename?: 'Query', myQuestions: { __typename?: 'MyQuestionPaginator', data: Array<{ __typename?: 'Question', id: string, question?: string | null, answer?: string | null, created_at?: any | null, positive_feedbacks_count?: number | null, negative_feedbacks_count?: number | null, product?: { __typename?: 'Product', id: string, name: string, slug: string, product_type: Types.ProductType, price?: number | null, sale_price?: number | null, min_price?: number | null, max_price?: number | null, quantity: number, unit: string, sku?: string | null, is_digital?: boolean | null, is_external?: boolean | null, ratings?: number | null, status: Types.ProductStatus, external_product_url?: string | null, external_product_button_text?: string | null, in_flash_sale?: number | null, type?: { __typename?: 'Type', id: string, name?: string | null, slug?: string | null, settings?: { __typename?: 'TypeSettings', productCard?: string | null } | null } | null, image?: { __typename?: 'Attachment', id?: string | null, thumbnail?: string | null, original?: string | null } | null, video?: Array<{ __typename?: 'Video', url: string }> | null, tags?: Array<{ __typename?: 'Tag', id: string, name: string, slug: string }> | null } | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, my_feedback?: { __typename?: 'Feedback', id: string, positive?: boolean | null, negative?: boolean | null } | null }>, paginatorInfo: { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number } } };

export type MyReportsQueryVariables = Types.Exact<{
  orderBy?: Types.InputMaybe<Array<Types.QueryMyReportsOrderByOrderByClause> | Types.QueryMyReportsOrderByOrderByClause>;
  first?: Types.InputMaybe<Types.Scalars['Int']['input']>;
  page?: Types.InputMaybe<Types.Scalars['Int']['input']>;
}>;


export type MyReportsQuery = { __typename?: 'Query', myReports: { __typename?: 'MyReportPaginator', data: Array<{ __typename?: 'AbusiveReport', id: string, user_id?: number | null, model_id?: string | null, model_type: string, message: string, created_at?: any | null, updated_at?: any | null, user: { __typename?: 'User', id: string, name: string, email: string } }>, paginatorInfo: { __typename?: 'PaginatorInfo', count: number, currentPage: number, firstItem: number, hasMorePages: boolean, lastItem: number, lastPage: number, perPage: number, total: number } } };

export type AbusiveReportPartsFragment = { __typename?: 'AbusiveReport', id: string, user_id?: number | null, model_id?: string | null, model_type: string, message: string, created_at?: any | null, updated_at?: any | null, user: { __typename?: 'User', id: string, name: string, email: string } };

export type GenerateDownloadableUrlMutationVariables = Types.Exact<{
  input: Types.GenerateDownloadableUrlInput;
}>;


export type GenerateDownloadableUrlMutation = { __typename?: 'Mutation', generateDownloadableUrl: string };

export type CreateQuestionMutationVariables = Types.Exact<{
  input: Types.CreateQuestionInput;
}>;


export type CreateQuestionMutation = { __typename?: 'Mutation', createQuestion: { __typename?: 'Question', id: string, question?: string | null, answer?: string | null, created_at?: any | null, positive_feedbacks_count?: number | null, negative_feedbacks_count?: number | null, user?: { __typename?: 'User', id: string, name: string, email: string } | null, my_feedback?: { __typename?: 'Feedback', id: string, positive?: boolean | null, negative?: boolean | null } | null } };

export type CreateFeedbackMutationVariables = Types.Exact<{
  input: Types.CreateFeedbackInput;
}>;


export type CreateFeedbackMutation = { __typename?: 'Mutation', createFeedback: { __typename?: 'Feedback', id: string, positive?: boolean | null, negative?: boolean | null } };

export type CreateAbuseReportMutationVariables = Types.Exact<{
  input: Types.CreateAbusiveReportInput;
}>;


export type CreateAbuseReportMutation = { __typename?: 'Mutation', createAbusiveReport: { __typename?: 'AbusiveReport', model_id?: string | null, message: string } };

export const QuestionPartsFragmentDoc = gql`
    fragment QuestionParts on Question {
  id
  question
  answer
  created_at
  user {
    id
    name
    email
  }
  positive_feedbacks_count
  negative_feedbacks_count
  my_feedback {
    id
    positive
    negative
  }
}
    `;
export const ProductPartsFragmentDoc = gql`
    fragment ProductParts on Product {
  id
  name
  slug
  type {
    id
    name
    slug
    settings {
      productCard
    }
  }
  product_type
  price
  sale_price
  min_price
  max_price
  quantity
  unit
  sku
  is_digital
  is_external
  ratings
  image {
    id
    thumbnail
    original
  }
  video {
    url
  }
  tags {
    id
    name
    slug
  }
  status
  external_product_url
  external_product_button_text
  in_flash_sale
}
    `;
export const PaginatorPartsFragmentDoc = gql`
    fragment PaginatorParts on PaginatorInfo {
  count
  currentPage
  firstItem
  hasMorePages
  lastItem
  lastPage
  perPage
  total
}
    `;
export const AuthorPartsFragmentDoc = gql`
    fragment AuthorParts on Author {
  id
  name
  is_approved
  slug
  bio
  quote
  born
  death
  languages
  socials {
    url
    icon
  }
  image {
    id
    original
    thumbnail
  }
  cover_image {
    id
    original
    thumbnail
  }
}
    `;
export const PaymentIntentPartsFragmentDoc = gql`
    fragment PaymentIntentParts on PaymentIntent {
  id
  order_id
  payment_gateway
  tracking_number
  payment_intent_info {
    client_secret
    is_redirect
    payment_id
    redirect_url
    amount
    currency
  }
}
    `;
export const AbusiveReportPartsFragmentDoc = gql`
    fragment AbusiveReportParts on AbusiveReport {
  id
  user_id
  user {
    id
    name
    email
  }
  model_id
  model_type
  message
  created_at
  updated_at
}
    `;
export const ProductsDocument = gql`
    query Products($search: String, $date_range: String, $orderBy: String, $sortedBy: String, $language: String, $searchJoin: String = "AND", $first: Int = 15, $page: Int) {
  products(
    search: $search
    date_range: $date_range
    sortedBy: $sortedBy
    orderBy: $orderBy
    language: $language
    searchJoin: $searchJoin
    first: $first
    page: $page
  ) {
    data {
      ...ProductParts
      author {
        name
        slug
        id
      }
    }
    paginatorInfo {
      ...PaginatorParts
    }
  }
}
    ${ProductPartsFragmentDoc}
${PaginatorPartsFragmentDoc}`;

/**
 * __useProductsQuery__
 *
 * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductsQuery({
 *   variables: {
 *      search: // value for 'search'
 *      date_range: // value for 'date_range'
 *      orderBy: // value for 'orderBy'
 *      sortedBy: // value for 'sortedBy'
 *      language: // value for 'language'
 *      searchJoin: // value for 'searchJoin'
 *      first: // value for 'first'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useProductsQuery(baseOptions?: Apollo.QueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
      }
export function useProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export function useProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export type ProductsQueryHookResult = ReturnType<typeof useProductsQuery>;
export type ProductsLazyQueryHookResult = ReturnType<typeof useProductsLazyQuery>;
export type ProductsSuspenseQueryHookResult = ReturnType<typeof useProductsSuspenseQuery>;
export type ProductsQueryResult = Apollo.QueryResult<ProductsQuery, ProductsQueryVariables>;
export const ProductDocument = gql`
    query Product($id: ID, $slug: String, $language: String) {
  product(id: $id, slug: $slug, language: $language) {
    ...ProductParts
    author {
      ...AuthorParts
    }
    manufacturer {
      id
      name
      slug
    }
    shop_id
    shop {
      id
      name
      slug
    }
    description
    categories {
      id
      name
      slug
      children {
        id
        name
        slug
      }
    }
    gallery {
      id
      thumbnail
      original
    }
    video {
      url
    }
    variations {
      id
      value
      meta
      attribute {
        id
        name
        slug
      }
    }
    variation_options {
      id
      title
      price
      sale_price
      quantity
      is_disable
      image {
        id
        thumbnail
        original
      }
      options {
        name
        value
      }
    }
    author {
      id
      name
      slug
    }
    related_products(limit: 8) {
      ...ProductParts
    }
  }
}
    ${ProductPartsFragmentDoc}
${AuthorPartsFragmentDoc}`;

/**
 * __useProductQuery__
 *
 * To run a query within a React component, call `useProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *      slug: // value for 'slug'
 *      language: // value for 'language'
 *   },
 * });
 */
export function useProductQuery(baseOptions?: Apollo.QueryHookOptions<ProductQuery, ProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
      }
export function useProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export function useProductSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export type ProductQueryHookResult = ReturnType<typeof useProductQuery>;
export type ProductLazyQueryHookResult = ReturnType<typeof useProductLazyQuery>;
export type ProductSuspenseQueryHookResult = ReturnType<typeof useProductSuspenseQuery>;
export type ProductQueryResult = Apollo.QueryResult<ProductQuery, ProductQueryVariables>;
export const PopularProductsDocument = gql`
    query PopularProducts($limit: Int, $type_slug: String, $range: Int) {
  popularProducts(limit: $limit, type_slug: $type_slug, range: $range) {
    ...ProductParts
    author {
      name
      slug
      id
    }
  }
}
    ${ProductPartsFragmentDoc}`;

/**
 * __usePopularProductsQuery__
 *
 * To run a query within a React component, call `usePopularProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePopularProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePopularProductsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type_slug: // value for 'type_slug'
 *      range: // value for 'range'
 *   },
 * });
 */
export function usePopularProductsQuery(baseOptions?: Apollo.QueryHookOptions<PopularProductsQuery, PopularProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PopularProductsQuery, PopularProductsQueryVariables>(PopularProductsDocument, options);
      }
export function usePopularProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PopularProductsQuery, PopularProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PopularProductsQuery, PopularProductsQueryVariables>(PopularProductsDocument, options);
        }
export function usePopularProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PopularProductsQuery, PopularProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PopularProductsQuery, PopularProductsQueryVariables>(PopularProductsDocument, options);
        }
export type PopularProductsQueryHookResult = ReturnType<typeof usePopularProductsQuery>;
export type PopularProductsLazyQueryHookResult = ReturnType<typeof usePopularProductsLazyQuery>;
export type PopularProductsSuspenseQueryHookResult = ReturnType<typeof usePopularProductsSuspenseQuery>;
export type PopularProductsQueryResult = Apollo.QueryResult<PopularProductsQuery, PopularProductsQueryVariables>;
export const BestSellingProductsDocument = gql`
    query BestSellingProducts($limit: Int, $type_slug: String, $range: Int) {
  bestSellingProducts(limit: $limit, type_slug: $type_slug, range: $range) {
    ...ProductParts
    author {
      name
      slug
      id
    }
  }
}
    ${ProductPartsFragmentDoc}`;

/**
 * __useBestSellingProductsQuery__
 *
 * To run a query within a React component, call `useBestSellingProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBestSellingProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBestSellingProductsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      type_slug: // value for 'type_slug'
 *      range: // value for 'range'
 *   },
 * });
 */
export function useBestSellingProductsQuery(baseOptions?: Apollo.QueryHookOptions<BestSellingProductsQuery, BestSellingProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BestSellingProductsQuery, BestSellingProductsQueryVariables>(BestSellingProductsDocument, options);
      }
export function useBestSellingProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BestSellingProductsQuery, BestSellingProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BestSellingProductsQuery, BestSellingProductsQueryVariables>(BestSellingProductsDocument, options);
        }
export function useBestSellingProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BestSellingProductsQuery, BestSellingProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BestSellingProductsQuery, BestSellingProductsQueryVariables>(BestSellingProductsDocument, options);
        }
export type BestSellingProductsQueryHookResult = ReturnType<typeof useBestSellingProductsQuery>;
export type BestSellingProductsLazyQueryHookResult = ReturnType<typeof useBestSellingProductsLazyQuery>;
export type BestSellingProductsSuspenseQueryHookResult = ReturnType<typeof useBestSellingProductsSuspenseQuery>;
export type BestSellingProductsQueryResult = Apollo.QueryResult<BestSellingProductsQuery, BestSellingProductsQueryVariables>;
export const DownloadableProductsDocument = gql`
    query DownloadableProducts($first: Int = 15, $page: Int) {
  downloads(first: $first, page: $page) {
    data {
      file {
        fileable {
          __typename
          ... on Product {
            name
            slug
            image {
              id
              thumbnail
              original
            }
            shop {
              name
              slug
            }
          }
          ... on Variation {
            title
            product {
              name
              image {
                id
                thumbnail
                original
              }
            }
            image {
              id
            }
          }
        }
      }
      id
      purchase_key
      digital_file_id
      tracking_number
      order {
        payment_status
        order_status
        payment_intent {
          ...PaymentIntentParts
        }
        payment_gateway
      }
      created_at
    }
    paginatorInfo {
      ...PaginatorParts
    }
  }
}
    ${PaymentIntentPartsFragmentDoc}
${PaginatorPartsFragmentDoc}`;

/**
 * __useDownloadableProductsQuery__
 *
 * To run a query within a React component, call `useDownloadableProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDownloadableProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDownloadableProductsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useDownloadableProductsQuery(baseOptions?: Apollo.QueryHookOptions<DownloadableProductsQuery, DownloadableProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DownloadableProductsQuery, DownloadableProductsQueryVariables>(DownloadableProductsDocument, options);
      }
export function useDownloadableProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DownloadableProductsQuery, DownloadableProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DownloadableProductsQuery, DownloadableProductsQueryVariables>(DownloadableProductsDocument, options);
        }
export function useDownloadableProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DownloadableProductsQuery, DownloadableProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DownloadableProductsQuery, DownloadableProductsQueryVariables>(DownloadableProductsDocument, options);
        }
export type DownloadableProductsQueryHookResult = ReturnType<typeof useDownloadableProductsQuery>;
export type DownloadableProductsLazyQueryHookResult = ReturnType<typeof useDownloadableProductsLazyQuery>;
export type DownloadableProductsSuspenseQueryHookResult = ReturnType<typeof useDownloadableProductsSuspenseQuery>;
export type DownloadableProductsQueryResult = Apollo.QueryResult<DownloadableProductsQuery, DownloadableProductsQueryVariables>;
export const QuestionsDocument = gql`
    query Questions($shop_id: ID, $orderBy: [QueryQuestionsOrderByOrderByClause!], $first: Int = 15, $page: Int) {
  questions(shop_id: $shop_id, orderBy: $orderBy, first: $first, page: $page) {
    data {
      ...QuestionParts
    }
    paginatorInfo {
      ...PaginatorParts
    }
  }
}
    ${QuestionPartsFragmentDoc}
${PaginatorPartsFragmentDoc}`;

/**
 * __useQuestionsQuery__
 *
 * To run a query within a React component, call `useQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuestionsQuery({
 *   variables: {
 *      shop_id: // value for 'shop_id'
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
      }
export function useQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
        }
export function useQuestionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<QuestionsQuery, QuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QuestionsQuery, QuestionsQueryVariables>(QuestionsDocument, options);
        }
export type QuestionsQueryHookResult = ReturnType<typeof useQuestionsQuery>;
export type QuestionsLazyQueryHookResult = ReturnType<typeof useQuestionsLazyQuery>;
export type QuestionsSuspenseQueryHookResult = ReturnType<typeof useQuestionsSuspenseQuery>;
export type QuestionsQueryResult = Apollo.QueryResult<QuestionsQuery, QuestionsQueryVariables>;
export const MyQuestionsDocument = gql`
    query MyQuestions($orderBy: [QueryMyQuestionsOrderByOrderByClause!], $first: Int = 15, $page: Int) {
  myQuestions(orderBy: $orderBy, first: $first, page: $page) {
    data {
      ...QuestionParts
      product {
        ...ProductParts
      }
    }
    paginatorInfo {
      ...PaginatorParts
    }
  }
}
    ${QuestionPartsFragmentDoc}
${ProductPartsFragmentDoc}
${PaginatorPartsFragmentDoc}`;

/**
 * __useMyQuestionsQuery__
 *
 * To run a query within a React component, call `useMyQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyQuestionsQuery({
 *   variables: {
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useMyQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<MyQuestionsQuery, MyQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyQuestionsQuery, MyQuestionsQueryVariables>(MyQuestionsDocument, options);
      }
export function useMyQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyQuestionsQuery, MyQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyQuestionsQuery, MyQuestionsQueryVariables>(MyQuestionsDocument, options);
        }
export function useMyQuestionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MyQuestionsQuery, MyQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyQuestionsQuery, MyQuestionsQueryVariables>(MyQuestionsDocument, options);
        }
export type MyQuestionsQueryHookResult = ReturnType<typeof useMyQuestionsQuery>;
export type MyQuestionsLazyQueryHookResult = ReturnType<typeof useMyQuestionsLazyQuery>;
export type MyQuestionsSuspenseQueryHookResult = ReturnType<typeof useMyQuestionsSuspenseQuery>;
export type MyQuestionsQueryResult = Apollo.QueryResult<MyQuestionsQuery, MyQuestionsQueryVariables>;
export const MyReportsDocument = gql`
    query MyReports($orderBy: [QueryMyReportsOrderByOrderByClause!], $first: Int = 15, $page: Int) {
  myReports(orderBy: $orderBy, first: $first, page: $page) {
    data {
      ...AbusiveReportParts
    }
    paginatorInfo {
      ...PaginatorParts
    }
  }
}
    ${AbusiveReportPartsFragmentDoc}
${PaginatorPartsFragmentDoc}`;

/**
 * __useMyReportsQuery__
 *
 * To run a query within a React component, call `useMyReportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyReportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyReportsQuery({
 *   variables: {
 *      orderBy: // value for 'orderBy'
 *      first: // value for 'first'
 *      page: // value for 'page'
 *   },
 * });
 */
export function useMyReportsQuery(baseOptions?: Apollo.QueryHookOptions<MyReportsQuery, MyReportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyReportsQuery, MyReportsQueryVariables>(MyReportsDocument, options);
      }
export function useMyReportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyReportsQuery, MyReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyReportsQuery, MyReportsQueryVariables>(MyReportsDocument, options);
        }
export function useMyReportsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MyReportsQuery, MyReportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyReportsQuery, MyReportsQueryVariables>(MyReportsDocument, options);
        }
export type MyReportsQueryHookResult = ReturnType<typeof useMyReportsQuery>;
export type MyReportsLazyQueryHookResult = ReturnType<typeof useMyReportsLazyQuery>;
export type MyReportsSuspenseQueryHookResult = ReturnType<typeof useMyReportsSuspenseQuery>;
export type MyReportsQueryResult = Apollo.QueryResult<MyReportsQuery, MyReportsQueryVariables>;
export const GenerateDownloadableUrlDocument = gql`
    mutation GenerateDownloadableUrl($input: GenerateDownloadableUrlInput!) {
  generateDownloadableUrl(input: $input)
}
    `;
export type GenerateDownloadableUrlMutationFn = Apollo.MutationFunction<GenerateDownloadableUrlMutation, GenerateDownloadableUrlMutationVariables>;

/**
 * __useGenerateDownloadableUrlMutation__
 *
 * To run a mutation, you first call `useGenerateDownloadableUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateDownloadableUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateDownloadableUrlMutation, { data, loading, error }] = useGenerateDownloadableUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useGenerateDownloadableUrlMutation(baseOptions?: Apollo.MutationHookOptions<GenerateDownloadableUrlMutation, GenerateDownloadableUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateDownloadableUrlMutation, GenerateDownloadableUrlMutationVariables>(GenerateDownloadableUrlDocument, options);
      }
export type GenerateDownloadableUrlMutationHookResult = ReturnType<typeof useGenerateDownloadableUrlMutation>;
export type GenerateDownloadableUrlMutationResult = Apollo.MutationResult<GenerateDownloadableUrlMutation>;
export type GenerateDownloadableUrlMutationOptions = Apollo.BaseMutationOptions<GenerateDownloadableUrlMutation, GenerateDownloadableUrlMutationVariables>;
export const CreateQuestionDocument = gql`
    mutation CreateQuestion($input: CreateQuestionInput!) {
  createQuestion(input: $input) {
    ...QuestionParts
  }
}
    ${QuestionPartsFragmentDoc}`;
export type CreateQuestionMutationFn = Apollo.MutationFunction<CreateQuestionMutation, CreateQuestionMutationVariables>;

/**
 * __useCreateQuestionMutation__
 *
 * To run a mutation, you first call `useCreateQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createQuestionMutation, { data, loading, error }] = useCreateQuestionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateQuestionMutation(baseOptions?: Apollo.MutationHookOptions<CreateQuestionMutation, CreateQuestionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateQuestionMutation, CreateQuestionMutationVariables>(CreateQuestionDocument, options);
      }
export type CreateQuestionMutationHookResult = ReturnType<typeof useCreateQuestionMutation>;
export type CreateQuestionMutationResult = Apollo.MutationResult<CreateQuestionMutation>;
export type CreateQuestionMutationOptions = Apollo.BaseMutationOptions<CreateQuestionMutation, CreateQuestionMutationVariables>;
export const CreateFeedbackDocument = gql`
    mutation CreateFeedback($input: CreateFeedbackInput!) {
  createFeedback(input: $input) {
    id
    positive
    negative
  }
}
    `;
export type CreateFeedbackMutationFn = Apollo.MutationFunction<CreateFeedbackMutation, CreateFeedbackMutationVariables>;

/**
 * __useCreateFeedbackMutation__
 *
 * To run a mutation, you first call `useCreateFeedbackMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFeedbackMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFeedbackMutation, { data, loading, error }] = useCreateFeedbackMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFeedbackMutation(baseOptions?: Apollo.MutationHookOptions<CreateFeedbackMutation, CreateFeedbackMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFeedbackMutation, CreateFeedbackMutationVariables>(CreateFeedbackDocument, options);
      }
export type CreateFeedbackMutationHookResult = ReturnType<typeof useCreateFeedbackMutation>;
export type CreateFeedbackMutationResult = Apollo.MutationResult<CreateFeedbackMutation>;
export type CreateFeedbackMutationOptions = Apollo.BaseMutationOptions<CreateFeedbackMutation, CreateFeedbackMutationVariables>;
export const CreateAbuseReportDocument = gql`
    mutation CreateAbuseReport($input: CreateAbusiveReportInput!) {
  createAbusiveReport(input: $input) {
    model_id
    message
  }
}
    `;
export type CreateAbuseReportMutationFn = Apollo.MutationFunction<CreateAbuseReportMutation, CreateAbuseReportMutationVariables>;

/**
 * __useCreateAbuseReportMutation__
 *
 * To run a mutation, you first call `useCreateAbuseReportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAbuseReportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAbuseReportMutation, { data, loading, error }] = useCreateAbuseReportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateAbuseReportMutation(baseOptions?: Apollo.MutationHookOptions<CreateAbuseReportMutation, CreateAbuseReportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAbuseReportMutation, CreateAbuseReportMutationVariables>(CreateAbuseReportDocument, options);
      }
export type CreateAbuseReportMutationHookResult = ReturnType<typeof useCreateAbuseReportMutation>;
export type CreateAbuseReportMutationResult = Apollo.MutationResult<CreateAbuseReportMutation>;
export type CreateAbuseReportMutationOptions = Apollo.BaseMutationOptions<CreateAbuseReportMutation, CreateAbuseReportMutationVariables>;